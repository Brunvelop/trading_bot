import logging
from typing import Dict, Any, Optional

from exchange_apis import BaseExchangeAPI
from definitions import MarketData, Memory
from strategies import Strategy, ActionType

# Basic logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

class Trader:
    """
    Class that acts as an orchestrator between trading strategies and exchange APIs.
    Executes actions generated by strategies, translating these actions into concrete orders.
    """
    
    def __init__(self, strategy: Strategy, exchange_api: BaseExchangeAPI, pair: str = 'BTC/USD') -> None:
        """
        Initializes the Trader with a strategy, an exchange API and a trading pair.
        
        Args:
            strategy: Strategy that will generate trading actions
            exchange_api: Exchange API to execute orders
            pair: Trading pair (default 'BTC/USD')
        """
        self.strategy = strategy
        self.exchange_api = exchange_api
        self.pair = pair
        self.logger = logging.getLogger(f"Trader-{pair}")

    def execute_strategy(self, data: MarketData, memory: Memory) -> None:
        """
        Executes the strategy with the provided market data and memory.
        Processes each action generated by the strategy and executes it on the exchange.
        
        Args:
            data: Market data for the strategy
            memory: Current state of memory (balances, orders, etc.)
            
        Raises:
            ValueError: If an unrecognized action is found
        """
        try:
            self.logger.info(f"Executing strategy for {self.pair}")
            actions = self.strategy.run(data, memory)
            
            for action in actions:
                self.logger.info(f"Processing action: {action.action_type.value} - Price: {action.price} - Amount: {action.amount}")
                
                # Validate sufficient balance for the action
                if action.action_type in [ActionType.BUY_MARKET, ActionType.BUY_LIMIT] and action.amount * action.price > memory.balance_b:
                    self.logger.warning(f"Insufficient balance for buy. Required: {action.amount * action.price}, Available: {memory.balance_b}")
                    continue
                
                if action.action_type in [ActionType.SELL_MARKET, ActionType.SELL_LIMIT] and action.amount > memory.balance_a:
                    self.logger.warning(f"Insufficient balance for sell. Required: {action.amount}, Available: {memory.balance_a}")
                    continue
                
                # Execute the corresponding action
                try:
                    match action.action_type:
                        case ActionType.BUY_MARKET: self.buy_market(action.price, action.amount)
                        case ActionType.SELL_MARKET: self.sell_market(action.price, action.amount)
                        case ActionType.BUY_LIMIT: self.buy_limit(action.price, action.amount)
                        case ActionType.SELL_LIMIT: self.sell_limit(action.price, action.amount)
                        case ActionType.STOP_LOSS: self.set_stop_loss(action.price, action.amount)
                        case ActionType.TAKE_PROFIT: self.set_take_profit(action.price, action.amount)
                        case _: raise ValueError(f"Unrecognized action: {action}")
                except Exception as e:
                    self.logger.error(f"Error executing action {action.action_type.value}: {str(e)}")
        except Exception as e:
            self.logger.error(f"Error executing strategy: {str(e)}")
            raise

    def buy_market(self, price: float, amount: float) -> Dict[str, Any]:
        """
        Executes a market buy order.
        
        Args:
            price: Order price
            amount: Amount to buy
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Executing market buy - Price: {price} - Amount: {amount}")
        try:
            result = self.exchange_api.create_order(self.pair, 'market', 'buy', amount, price)
            self.logger.info(f"Buy order executed: {result.get('id', 'N/A')}")
            return result
        except Exception as e:
            self.logger.error(f"Error executing market buy: {str(e)}")
            raise

    def sell_market(self, price: float, amount: float) -> Dict[str, Any]:
        """
        Executes a market sell order.
        
        Args:
            price: Order price
            amount: Amount to sell
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Executing market sell - Price: {price} - Amount: {amount}")
        try:
            result = self.exchange_api.create_order(self.pair, 'market', 'sell', amount, price)
            self.logger.info(f"Sell order executed: {result.get('id', 'N/A')}")
            return result
        except Exception as e:
            self.logger.error(f"Error executing market sell: {str(e)}")
            raise
    
    def buy_limit(self, price: float, amount: float) -> Dict[str, Any]:
        """
        Executes a limit buy order.
        
        Args:
            price: Limit price for the buy
            amount: Amount to buy
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Executing limit buy - Price: {price} - Amount: {amount}")
        try:
            result = self.exchange_api.create_order(self.pair, 'limit', 'buy', amount, price)
            self.logger.info(f"Limit buy order created: {result.get('id', 'N/A')}")
            return result
        except Exception as e:
            self.logger.error(f"Error creating limit buy order: {str(e)}")
            raise

    def sell_limit(self, price: float, amount: float) -> Dict[str, Any]:
        """
        Executes a limit sell order.
        
        Args:
            price: Limit price for the sell
            amount: Amount to sell
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Executing limit sell - Price: {price} - Amount: {amount}")
        try:
            result = self.exchange_api.create_order(self.pair, 'limit', 'sell', amount, price)
            self.logger.info(f"Limit sell order created: {result.get('id', 'N/A')}")
            return result
        except Exception as e:
            self.logger.error(f"Error creating limit sell order: {str(e)}")
            raise

    def set_stop_loss(self, price: float, amount: float) -> Dict[str, Any]:
        """
        Sets a stop loss order.
        
        Args:
            price: Stop loss trigger price
            amount: Amount to sell when triggered
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Setting stop loss - Price: {price} - Amount: {amount}")
        try:
            # Exact implementation may vary by exchange
            result = self.exchange_api.create_order(
                self.pair, 
                'stop_loss', 
                'sell', 
                amount, 
                price, 
                {'stopPrice': price}
            )
            self.logger.info(f"Stop loss order created: {result.get('id', 'N/A')}")
            return result
        except Exception as e:
            self.logger.error(f"Error creating stop loss order: {str(e)}")
            raise

    def set_take_profit(self, price: float, amount: float) -> Dict[str, Any]:
        """
        Sets a take profit order.
        
        Args:
            price: Take profit trigger price
            amount: Amount to sell when triggered
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Setting take profit - Price: {price} - Amount: {amount}")
        try:
            # Exact implementation may vary by exchange
            result = self.exchange_api.create_order(
                self.pair, 
                'take_profit', 
                'sell', 
                amount, 
                price, 
                {'triggerPrice': price}
            )
            self.logger.info(f"Take profit order created: {result.get('id', 'N/A')}")
            return result
        except Exception as e:
            self.logger.error(f"Error creating take profit order: {str(e)}")
            raise
            
    def cancel_order(self, order_id: str) -> Dict[str, Any]:
        """
        Cancels an existing order.
        
        Args:
            order_id: ID of the order to cancel
            
        Returns:
            Exchange response
        """
        self.logger.info(f"Cancelling order: {order_id}")
        try:
            result = self.exchange_api.cancel_order(order_id, self.pair)
            self.logger.info(f"Order cancelled: {order_id}")
            return result
        except Exception as e:
            self.logger.error(f"Error cancelling order {order_id}: {str(e)}")
            raise
            
    def get_order_status(self, order_id: str) -> Dict[str, Any]:
        """
        Gets the status of an order.
        
        Args:
            order_id: ID of the order
            
        Returns:
            Order status
        """
        self.logger.info(f"Querying order status: {order_id}")
        try:
            result = self.exchange_api.get_order(order_id, self.pair)
            self.logger.info(f"Order status {order_id}: {result.get('status', 'unknown')}")
            return result
        except Exception as e:
            self.logger.error(f"Error querying order status {order_id}: {str(e)}")
            raise
